/*
 * Created on 2006-08-31
 *
 * @author M.Olszewski
 */

package net.java.dante.algorithms;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

import net.java.dante.algorithms.data.AlgorithmData;
import net.java.dante.algorithms.message.AlgorithmExceptionMessage;
import net.java.dante.algorithms.message.AlgorithmFinishedMessage;
import net.java.dante.algorithms.message.CommandsReadyMessage;
import net.java.dante.receiver.Receiver;
import net.java.dante.sim.command.AgentCommands;
import net.java.dante.sim.command.CommandsRepository;
import net.java.dante.sim.io.TimeSyncData;
import net.java.dante.sim.io.UpdateData;
import net.java.dante.sim.io.init.InitializationData;

/**
 * Base class for all algorithms running on client's side, using {@link Receiver}
 * to send commands generated by this algorithm.
 * Each algorithm must implement its own version of {@link #runAlgorithm()} method.
 * In this method algorithm can call one of the specified methods to
 * perform some specified actions:
 * <ul>
 * <li>{{@link #getAlgorithmData()}} returns reference to object containing
 *     data that should be used by algorithm. To refresh contents of this
 *     data one must call {@link AlgorithmData#refresh()} method. Otherwise
 *     algorithm will use old and probably not accurate data. To determine
 *     how often algorithm's data should be refreshed, call its method
 *     {@link AlgorithmData#getBestRefreshRate()} and use returned value.
 * <li>{@link #sendCommands(CommandsRepository)} to send commands repository
 *     to server.
 * <li>{@link #isRunning()} returns <code>true</code> whether algorithm
 *     should be running or <code>false</code> otherwise. This method
 *     should be called from time to time and if <code>false</code> value
 *     is returned, algorithm should stop execution as soon as possible.
 *     If algorithm will not obey this condition, client's performance
 *     can be lowered significantly.
 * </ul>
 * To finish algorithm's execution, simply return from {@link #runAlgorithm()}
 * method - but be aware than once finished, algorithm will not be restarted
 * again.
 *
 * @author M.Olszewski
 */
public abstract class BaseAlgorithmImpl extends BaseAlgorithm
{
  /** Value indicating whether algorithm is running. */
  private AtomicBoolean running = new AtomicBoolean();
  /** Algorithm's data. */
  private AlgorithmDataImpl data;
  /** Messages receiver. */
  private Receiver receiver;


  /**
   * Creates instance of {@link BaseAlgorithmImpl} class.
   *
   * @param waitForUpdate determines whether calls to {@link #refreshAndObtain()}
   *        or {@link AlgorithmData#refresh()} methods should wait until
   *        any data arrives.
   */
  public BaseAlgorithmImpl(boolean waitForUpdate)
  {
    if (waitForUpdate)
    {
      data = new AlgorithmDataImpl(UpdatesQueue.createBlockingQueue());
    }
    else
    {
      data = new AlgorithmDataImpl(UpdatesQueue.createNonBlockingQueue());
    }
  }


  /**
   * Initializes algorithm using the specified parameters.
   *
   * @param messagesReceiver messages receiver.
   * @param initData initialization data for algorithm.
   */
  public final void initAlgorithm(Receiver messagesReceiver, InitializationData initData)
  {
    if (messagesReceiver == null)
    {
      throw new NullPointerException("Specified messagesReceiver is null!");
    }
    if (initData == null)
    {
      throw new NullPointerException("Specified initData is null!");
    }

    receiver = messagesReceiver;
    data.initialize(initData);
  }

  /**
   * Runs algorithm.
   * Implementations of this method should check sometimes whether
   * algorithm should be still running by calling {@link #isRunning()} method.
   */
  protected abstract void runAlgorithm();

  /**
   * Checks whether algorithm should be running.
   *
   * @return Returns <code>true</code> if algorithm should be running,
   *         <code>false</code> otherwise.
   */
  protected final boolean isRunning()
  {
    return running.get();
  }

  /**
   * Starts running algorithm.
   */
  final void startRunning()
  {
    running.set(true);
  }

  /**
   * Request for algorithm to stop running.
   */
  public final void requestStopRunning()
  {
    running.set(false);
    addTimeSyncData(new TimeSyncData(0, 0));
  }

  /**
   * Gets algorithm's data.
   *
   * @return Returns algorithm's data.
   */
  protected final AlgorithmData getAlgorithmData()
  {
    return data;
  }

  /**
   * Rebuilds this {@link AlgorithmData} data by using next events repository
   * from the queue and returns instance of {@link UpdateData} object
   * which was used during rebuilt process. This method may return
   * <code>null</code> if no update was performed.
   *
   * @return Returns instance of {@link UpdateData} object which was used
   *         during rebuilt process.
   */
  protected final UpdateData refreshAndObtain()
  {
    return data.refreshAndObtain();
  }

  /**
   * Adds the specified time synchronization data to updates repository
   * in this algorithm's data.
   *
   * @param timeData the specified time synchronization data.
   */
  public final void addTimeSyncData(TimeSyncData timeData)
  {
    data.addTimeData(timeData);
  }

  /**
   * Adds the specified update data to updates repository
   * in this algorithm's data.
   *
   * @param updateData the specified time synchronization data.
   */
  public final void addUpdateData(UpdateData updateData)
  {
    data.addUpdateData(updateData);
  }

  /**
   * Sends the specified commands repository to server.
   *
   * @param commands - the specified commands repository.
   */
  protected final void sendCommands(CommandsRepository commands)
  {
    if (commands != null)
    {
      Set<Integer> commandsIds = new HashSet<Integer>(commands.getCommandsCount());

      for (int i = 0; i < commands.getAgentCommandsCount(); i++)
      {
        AgentCommands ac = commands.getAgentCommands(i);
        for (int j = 0; j < ac.getCommandsCount(); j++)
        {
          commandsIds.add(Integer.valueOf(ac.getCommandId(j)));
        }
      }

      receiver.postMessage(new CommandsReadyMessage(commands));
    }
  }

  /**
   * Sends notification that this algorithm is finished.
   */
  final void finished()
  {
    receiver.postMessage(new AlgorithmFinishedMessage());
  }

  /**
   * Sends notification that exception was caught while running algorithm.
   *
   * @param cause cause of exception.
   */
  final void exceptionCaught(Throwable cause)
  {
    receiver.postMessage(new AlgorithmExceptionMessage(cause));
  }
}